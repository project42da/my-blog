---
title: "이친수 (2193)"
date: "2019-02-07 23:00:00 +0900"
categories: "알고리즘"
tags: ["알고리즘", "다이나믹프로그래밍", "백준"]

---
([문제링크](https://www.acmicpc.net/problem/2193))

이친수의 규칙은 다음 두 가지이다.

1. 이친수는 0으로 시작하지 않는다.
1. 이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.

<br>

좀더 쉽게 해석하면 다음과 같다.

1. N자리 이친수의 첫째자리는 무조건 1로 시작한다.
1. $0$ 다음에는 $1$이나 $0$이 올 수 있지만, $1$다음에는 $0$만 올 수 있다.

<br>
이 규칙을 토대로 각 자리의 이친수 개수를 표로 표현할 수 있다.

|  0  |  1  |  2  |  3  |  4  |  5  |
|:---:|:---:|:---:|:---:|:---:|:---:|
|  0  |  0  |  1  |  1  |  2  |  3  |
|  1  |  1  |  0  |  1  |  1  |  2  |
|`SUM`|  1  |  1  |  2  |  3  |  5  |

```
d[1][0] = 0;
d[1][1] = 1; // 이친수는 1로만 시작할 수 있다.
d[2][0] = 1; // 그러므로 두번째 자리는 무조건 0만 가능하다.
d[2][1] = 0;
d[2][0] = 1; // 세번째 자리는 1, 0 모두 가능하다.
d[2][1] = 0;
```

**최종코드**

```c
#include <stdio.h>

long long d[91][2];
int main(){
    int n,i;
    scanf("%d", &n);

    d[1][0] = 0;
    d[1][1] = 1;
    d[2][0] = 1;
    d[2][1] = 0;

    for(i=3;i<=n;i++){
        d[i][0] = d[i-1][0] + d[i-1][1];
        d[i][1] = d[i-1][0];
    }

    printf("%lld", d[n][0] + d[n][1]);

    return 0;
}
```

**최종코드 2**

```c
#include <stdio.h>

long long d[91]={0,1,1};
int main(){
    int n,i;
    scanf("%d",&n);
    
    for(i=3;i<=n;i++){
        d[i]=d[i-2]+d[i-1];
    }
    
    printf("%lld",d[n]);
    return 0;
}
```

**최종코드 3**

```c
#include <stdio.h>

int main(){
    long long x = 1, y = 1, curr = 0, tmp = 0;
    int n,i;
    scanf("%d",&n);
    
    if(n < 3){
        printf("1");
    }else{
        while(n--){
            curr = x + y;
            if(n>2){
                tmp = y;
                y = curr;
                x = tmp;
            }
        }
        printf("%lld",curr);
    }
    return 0;
}
```